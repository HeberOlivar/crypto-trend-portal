from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict
from datetime import datetime
import json
import requests
import hmac
import hashlib
import time
import logging
import math

app = FastAPI()

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Adicionar middleware CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Permite todas as origens (ajuste conforme necessário)
    allow_credentials=True,
    allow_methods=["*"],  # Permite todos os métodos (GET, POST, DELETE, PUT, etc.)
    allow_headers=["*"],  # Permite todos os cabeçalhos
)

# Modelo para os ativos da carteira
class Asset(BaseModel):
    symbol: str
    amount_in_usd: float
    leverage: int

class Portfolio(BaseModel):
    id: int
    user_id: int
    name: str
    total_amount: float
    exchange: str
    api_key: str
    api_secret: str
    assets: List[Asset]

# Modelo para o login
class LoginRequest(BaseModel):
    username: str
    password: str

# Modelo para o signal
class SignalRequest(BaseModel):
    symbol: str
    trend: str
    amount_in_usd: float
    leverage: int

# Dicionário de mapeamento de erros da Bybit
BYBIT_ERROR_MESSAGES = {
    10001: "Parâmetro inválido. Verifique os dados enviados (ex.: símbolo ou quantidade inválida).",
    10002: "Timestamp dessincronizado. Tente novamente.",
    10004: "Erro de assinatura. Verifique as credenciais da API.",
    110001: "Saldo insuficiente para executar a ordem.",
    110043: "Alavancagem não modificada (leverage not modified).",
    130021: "Alavancagem inválida. Verifique o valor de alavancagem permitido para o símbolo.",
    130028: "Falha ao definir a alavancagem. Tente novamente."
}

# Função para carregar portfolios de um arquivo JSON
def load_portfolios():
    try:
        with open("portfolios.json", "r") as file:
            return json.load(file)
    except FileNotFoundError:
        # Se o arquivo não existir, retorna uma lista vazia
        return []
    except Exception as e:
        logger.error(f"Erro ao carregar portfolios.json: {str(e)}")
        return []

# Função para salvar portfolios em um arquivo JSON
def save_portfolios(portfolios):
    try:
        with open("portfolios.json", "w") as file:
            json.dump(portfolios, file, indent=4)
    except Exception as e:
        logger.error(f"Erro ao salvar portfolios.json: {str(e)}")

# Carrega os portfolios ao iniciar o servidor
portfolios_db = load_portfolios()

# Função para obter o horário do servidor da Bybit
def get_bybit_server_time() -> int:
    try:
        response = requests.get("https://api-testnet.bybit.com/v5/market/time")
        response.raise_for_status()
        data = response.json()
        if data["retCode"] != 0:
            raise Exception(data["retMsg"])
        # O horário do servidor está em "timeSecond"
        server_time = int(data["result"]["timeSecond"]) * 1000  # Converte de segundos para milissegundos
        logger.info(f"Horário do servidor da Bybit: {server_time}")
        return server_time
    except Exception as e:
        logger.error(f"Erro ao obter horário do servidor da Bybit: {str(e)}")
        # Fallback para o horário local
        local_time = int(time.time() * 1000)
        logger.warning(f"Usando horário local como fallback: {local_time}")
        return local_time

# Função para gerar a assinatura HMAC-SHA256 para a Bybit
def generate_bybit_signature(api_key: str, api_secret: str, timestamp: str, recv_window: str, body: str = None, query_params: Dict = None) -> str:
    # Base da string de assinatura
    param_str = f"{timestamp}{api_key}{recv_window}"
    
    # Para requisições GET, incluir os parâmetros da query string
    if query_params:
        # Ordena os parâmetros alfabeticamente e concatena no formato key=value
        sorted_params = sorted(query_params.items())
        query_str = "".join(f"{key}={value}" for key, value in sorted_params)
        param_str += query_str
    # Para requisições POST, incluir o corpo
    elif body:
        param_str += body
    
    logger.info(f"String de assinatura gerada: {param_str}")
    
    # Gera a assinatura HMAC-SHA256
    signature = hmac.new(
        api_secret.encode('utf-8'),
        param_str.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    logger.info(f"Assinatura gerada (X-BAPI-SIGN): {signature}")
    
    return signature

# Função para validar as credenciais na Bybit
def validate_bybit_credentials(api_key: str, api_secret: str) -> bool:
    max_attempts = 3
    for attempt in range(max_attempts):
        timestamp = str(get_bybit_server_time())
        recv_window = "10000"  # Janela de recebimento (10 segundos)
        
        # Para requisições GET sem parâmetros adicionais
        signature = generate_bybit_signature(api_key, api_secret, timestamp, recv_window, body=None, query_params=None)
        
        headers = {
            "X-BAPI-API-KEY": api_key,
            "X-BAPI-TIMESTAMP": timestamp,
            "X-BAPI-RECV-WINDOW": recv_window,
            "X-BAPI-SIGN": signature,
            "Content-Type": "application/json"
        }
        logger.info(f"Cabeçalhos da requisição (validação): {headers}")
        
        try:
            response = requests.get(
                "https://api-testnet.bybit.com/v5/user/query-api",
                headers=headers
            )
            data = response.json()
            logger.info(f"Resposta da validação de credenciais (tentativa {attempt + 1}): {data}")
            if data["retCode"] == 0:
                return True
            elif data["retCode"] == 10002:
                # Timestamp dessincronizado, tenta novamente
                logger.warning(f"Timestamp dessincronizado (tentativa {attempt + 1}): req_timestamp[{timestamp}], server_timestamp[{data['time']}]")
                if attempt == max_attempts - 1:
                    logger.error("Falha ao sincronizar timestamp após várias tentativas")
                    return False
                time.sleep(1)  # Pequena pausa antes de tentar novamente
                continue
            else:
                logger.error(f"Credenciais inválidas: {data['retMsg']}")
                return False
        except Exception as e:
            logger.error(f"Erro ao validar credenciais: {str(e)}")
            return False

# Função para obter informações do símbolo na Bybit (quantidade mínima, máxima e passo)
def get_symbol_info(symbol: str) -> Dict:
    try:
        response = requests.get(
            "https://api-testnet.bybit.com/v5/market/instruments-info",
            params={"category": "linear", "symbol": symbol}
        )
        response.raise_for_status()
        data = response.json()
        if data["retCode"] != 0:
            raise Exception(data["retMsg"])
        symbol_info = data["result"]["list"][0]
        return {
            "minOrderQty": float(symbol_info["lotSizeFilter"]["minOrderQty"]),
            "maxOrderQty": float(symbol_info["lotSizeFilter"]["maxOrderQty"]),
            "qtyStep": float(symbol_info["lotSizeFilter"]["qtyStep"])
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro ao obter informações do símbolo {symbol}: {str(e)}")

# Função para obter o preço atual do ativo na Bybit
def get_current_price(symbol: str) -> float:
    try:
        response = requests.get(
            "https://api-testnet.bybit.com/v5/market/tickers",
            params={"category": "linear", "symbol": symbol}
        )
        response.raise_for_status()
        data = response.json()
        if data["retCode"] != 0:
            raise Exception(data["retMsg"])
        # O preço está em "lastPrice"
        price = float(data["result"]["list"][0]["lastPrice"])
        return price
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro ao obter preço do ativo {symbol}: {str(e)}")

# Função para verificar o saldo da conta na Bybit
def check_balance(api_key: str, api_secret: str, amount_in_usd: float) -> bool:
    timestamp = str(get_bybit_server_time())
    recv_window = "10000"
    query_params = {"accountType": "UNIFIED"}  # Conta UTA
    
    # Gera a assinatura incluindo os parâmetros da query string
    signature = generate_bybit_signature(api_key, api_secret, timestamp, recv_window, body=None, query_params=query_params)
    
    headers = {
        "X-BAPI-API-KEY": api_key,
        "X-BAPI-TIMESTAMP": timestamp,
        "X-BAPI-RECV-WINDOW": recv_window,
        "X-BAPI-SIGN": signature,
        "Content-Type": "application/json"
    }
    logger.info(f"Cabeçalhos da requisição (verificação de saldo): {headers}")
    
    try:
        response = requests.get(
            "https://api-testnet.bybit.com/v5/account/wallet-balance",
            headers=headers,
            params=query_params
        )
        response.raise_for_status()
        data = response.json()
        logger.info(f"Resposta da verificação de saldo: {data}")
        
        if data["retCode"] != 0:
            error_msg = BYBIT_ERROR_MESSAGES.get(data["retCode"], data["retMsg"])
            raise HTTPException(status_code=500, detail=f"Erro ao verificar saldo: {error_msg} (retCode: {data['retCode']})")
        
        # Obtém o saldo disponível em USDT
        for coin in data["result"]["list"][0]["coin"]:
            if coin["coin"] == "USDT":
                wallet_balance = coin.get("walletBalance", "0")
                if not wallet_balance:
                    raise HTTPException(status_code=400, detail="Saldo da carteira (walletBalance) não disponível para USDT")
                available_balance = float(wallet_balance)
                logger.info(f"Saldo disponível em USDT (walletBalance): {available_balance}")
                if available_balance < amount_in_usd:
                    raise HTTPException(
                        status_code=400,
                        detail=f"Saldo insuficiente. Saldo disponível: {available_balance} USDT, necessário: {amount_in_usd} USDT"
                    )
                return True
        raise HTTPException(status_code=400, detail="USDT não encontrado na carteira")
    except requests.exceptions.RequestException as e:
        logger.error(f"Erro ao verificar saldo: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erro ao verificar saldo: {str(e)}")

# Função para definir a alavancagem na Bybit
def set_leverage(api_key: str, api_secret: str, symbol: str, leverage: int) -> bool:
    timestamp = str(get_bybit_server_time())
    recv_window = "10000"
    
    # Parâmetros para definir a alavancagem
    params = {
        "category": "linear",
        "symbol": symbol,
        "buyLeverage": str(leverage),
        "sellLeverage": str(leverage)
    }
    body = json.dumps(params, separators=(',', ':'))
    signature = generate_bybit_signature(api_key, api_secret, timestamp, recv_window, body=body, query_params=None)
    
    headers = {
        "X-BAPI-API-KEY": api_key,
        "X-BAPI-TIMESTAMP": timestamp,
        "X-BAPI-RECV-WINDOW": recv_window,
        "X-BAPI-SIGN": signature,
        "Content-Type": "application/json"
    }
    logger.info(f"Cabeçalhos da requisição (definição de alavancagem): {headers}")
    logger.info(f"Corpo da requisição (definição de alavancagem): {body}")
    
    try:
        response = requests.post(
            "https://api-testnet.bybit.com/v5/position/set-leverage",
            headers=headers,
            data=body
        )
        response_data = response.json()
        logger.info(f"Resposta da definição de alavancagem: {response_data}")
        
        # Ignora o erro 110043 (leverage not modified)
        if response_data["retCode"] != 0 and response_data["retCode"] != 110043:
            error_msg = BYBIT_ERROR_MESSAGES.get(response_data["retCode"], response_data["retMsg"])
            raise HTTPException(
                status_code=500,
                detail=f"Erro ao definir alavancagem: {error_msg} (retCode: {response_data['retCode']})"
            )
        return True
    except requests.exceptions.RequestException as e:
        logger.error(f"Erro ao definir alavancagem: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erro ao definir alavancagem: {str(e)}")

# Endpoint para login
@app.post("/login")
async def login(request: LoginRequest):
    if request.username == "user" and request.password == "pass":
        return {"user_id": 1}
    raise HTTPException(status_code=401, detail="Credenciais inválidas")

# Endpoint para buscar as criptomoedas disponíveis
@app.get("/cryptos")
async def get_cryptos():
    try:
        with open("cryptos.json", "r") as file:
            cryptos = json.load(file)
        return cryptos
    except FileNotFoundError:
        raise HTTPException(status_code=500, detail="Arquivo cryptos.json não encontrado")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro ao ler cryptos.json: {str(e)}")

# Endpoint para buscar as carteiras de um usuário
@app.get("/portfolios/{user_id}")
async def get_portfolios(user_id: int):
    user_portfolios = [p for p in portfolios_db if p["user_id"] == user_id]
    return user_portfolios

# Endpoint para criar uma nova carteira
@app.post("/portfolios/{user_id}")
async def create_portfolio(user_id: int, portfolio: Portfolio):
    global portfolios_db
    portfolio_dict = portfolio.dict()
    portfolio_dict["user_id"] = user_id
    portfolio_dict["created_at"] = datetime.now().isoformat()
    
    # Valida as credenciais antes de salvar
    if not validate_bybit_credentials(portfolio_dict["api_key"], portfolio_dict["api_secret"]):
        raise HTTPException(status_code=400, detail="Credenciais da Bybit inválidas")
    
    portfolios_db.append(portfolio_dict)
    save_portfolios(portfolios_db)  # Salva no arquivo JSON
    return {"portfolio_id": portfolio_dict["id"]}

# Endpoint para excluir uma carteira
@app.delete("/portfolios/{portfolio_id}")
async def delete_portfolio(portfolio_id: int):
    global portfolios_db
    portfolio = next((p for p in portfolios_db if p["id"] == portfolio_id), None)
    if not portfolio:
        raise HTTPException(status_code=404, detail="Carteira não encontrada")
    portfolios_db = [p for p in portfolios_db if p["id"] != portfolio_id]
    save_portfolios(portfolios_db)  # Salva no arquivo JSON
    return {"message": "Carteira excluída com sucesso"}

# Endpoint para atualizar uma carteira existente
@app.put("/portfolios/{portfolio_id}")
async def update_portfolio(portfolio_id: int, portfolio: Portfolio):
    global portfolios_db
    existing_portfolio = next((p for p in portfolios_db if p["id"] == portfolio_id), None)
    if not existing_portfolio:
        raise HTTPException(status_code=404, detail="Carteira não encontrada")
    
    portfolio_dict = portfolio.dict()
    portfolio_dict["user_id"] = existing_portfolio["user_id"]
    portfolio_dict["created_at"] = existing_portfolio["created_at"]
    
    # Valida as credenciais antes de salvar
    if not validate_bybit_credentials(portfolio_dict["api_key"], portfolio_dict["api_secret"]):
        raise HTTPException(status_code=400, detail="Credenciais da Bybit inválidas")
    
    portfolios_db = [p for p in portfolios_db if p["id"] != portfolio_id]
    portfolios_db.append(portfolio_dict)
    save_portfolios(portfolios_db)  # Salva no arquivo JSON
    return {"message": "Carteira atualizada com sucesso"}

# Endpoint para enviar um sinal para a Bybit
@app.post("/signal/{portfolio_id}")
async def send_signal(portfolio_id: int, signal: SignalRequest):
    # Busca as credenciais da carteira no portfolios_db
    portfolio = next((p for p in portfolios_db if p["id"] == portfolio_id), None)
    if not portfolio:
        raise HTTPException(status_code=404, detail="Carteira não encontrada")

    api_key = portfolio["api_key"]
    api_secret = portfolio["api_secret"]
    logger.info(f"Usando credenciais - api_key: {api_key}, api_secret: {api_secret}")

    # Valida as credenciais antes de prosseguir
    if not validate_bybit_credentials(api_key, api_secret):
        raise HTTPException(status_code=400, detail="Credenciais da Bybit inválidas")

    # Verifica o saldo da conta
    check_balance(api_key, api_secret, signal.amount_in_usd)

    # Obtém o preço atual do ativo
    price = get_current_price(signal.symbol)
    if price <= 0:
        raise HTTPException(status_code=400, detail="Preço do ativo inválido")

    # Obtém as informações do símbolo (quantidade mínima, máxima e passo)
    symbol_info = get_symbol_info(signal.symbol)
    min_order_qty = symbol_info["minOrderQty"]
    max_order_qty = symbol_info["maxOrderQty"]
    qty_step = symbol_info["qtyStep"]
    logger.info(f"Informações do símbolo {signal.symbol}: minOrderQty={min_order_qty}, maxOrderQty={max_order_qty}, qtyStep={qty_step}")

    # Calcula a quantidade (qty) com base no amount_in_usd e no preço atual
    qty = signal.amount_in_usd / price
    logger.info(f"Quantidade calculada (antes do ajuste): {qty}")

    # Ajusta a quantidade para ser um múltiplo de qty_step
    qty = math.floor(qty / qty_step) * qty_step
    logger.info(f"Quantidade ajustada (múltiplo de qtyStep): {qty}")

    # Valida a quantidade ajustada
    if qty < min_order_qty:
        raise HTTPException(
            status_code=400,
            detail=f"Quantidade ajustada ({qty}) é menor que a quantidade mínima permitida ({min_order_qty}) para {signal.symbol}"
        )
    if qty > max_order_qty:
        raise HTTPException(
            status_code=400,
            detail=f"Quantidade ajustada ({qty}) é maior que a quantidade máxima permitida ({max_order_qty}) para {signal.symbol}"
        )

    # Define a alavancagem para o símbolo
    set_leverage(api_key, api_secret, signal.symbol, signal.leverage)

    # Obtém o timestamp do servidor da Bybit
    timestamp = str(get_bybit_server_time())

    # Parâmetros para a chamada à Bybit
    recv_window = "10000"  # Janela de recebimento (10 segundos)
    
    # Dados da ordem para a Bybit
    order_params = {
        "category": "linear",  # Futuros lineares (USDT)
        "symbol": signal.symbol,
        "side": "Buy" if signal.trend == "up" else "Sell",
        "orderType": "Market",
        "qty": str(qty),  # Usa a quantidade ajustada
        "timeInForce": "GTC"
    }

    # Serializa os parâmetros como JSON (sem espaços extras)
    body = json.dumps(order_params, separators=(',', ':'))
    logger.info(f"Corpo da requisição (enviado): {body}")

    # Gera a assinatura usando o corpo JSON
    signature = generate_bybit_signature(api_key, api_secret, timestamp, recv_window, body=body, query_params=None)

    # Cabeçalhos para a chamada à Bybit
    headers = {
        "X-BAPI-API-KEY": api_key,
        "X-BAPI-TIMESTAMP": timestamp,
        "X-BAPI-RECV-WINDOW": recv_window,
        "X-BAPI-SIGN": signature,
        "Content-Type": "application/json"
    }
    logger.info(f"Cabeçalhos da requisição (criação de ordem): {headers}")

    # Faz a chamada à API da Bybit (usando Testnet)
    try:
        response = requests.post(
            "https://api-testnet.bybit.com/v5/order/create",
            headers=headers,
            data=body  # Envia o corpo como string
        )
        response_data = response.json()
        logger.info(f"Resposta da Bybit: {response_data}")
        
        # Verifica se há erro lógico na resposta da Bybit
        if response_data["retCode"] != 0:
            error_msg = BYBIT_ERROR_MESSAGES.get(response_data["retCode"], response_data["retMsg"])
            raise HTTPException(
                status_code=500,
                detail=f"Erro na API da Bybit: {error_msg} (retCode: {response_data['retCode']})"
            )
        
        return {"message": "Ordem enviada com sucesso", "bybit_response": response_data}
    except requests.exceptions.RequestException as e:
        logger.error(f"Erro ao enviar ordem para a Bybit: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Erro ao enviar ordem para a Bybit: {str(e)}")